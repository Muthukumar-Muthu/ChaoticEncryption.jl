var documenterSearchIndex = {"docs":
[{"location":"#ChaoticEncryption.jl","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"Encrypt and decrypt image files using Pseudo-Random Number Generators!","category":"page"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"CurrentModule = ChaoticEncryption","category":"page"},{"location":"#Index","page":"ChaoticEncryption.jl","title":"Index","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"","category":"page"},{"location":"#Pseudo-Random-Number-Generators","page":"ChaoticEncryption.jl","title":"Pseudo-Random Number Generators","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"logistic_key(\n    x_init::Float64,\n    r::Float64,\n    num_keys::Int64\n)","category":"page"},{"location":"#ChaoticEncryption.logistic_key-Tuple{Float64, Float64, Int64}","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.logistic_key","text":"logistic_key(x_init, r, num_keys)\n\nGenerates pseudo-random keys using the Logistic Map.\n\nThe equation -\n\nx_n+1 = r * x_n * (1 - x_n)\n\nArguments\n\nx_init::Float64: Initial value of x. x ϵ (0, 1).\nr::Float64: A constant value. Values > 4 usually results in pseudo-random numbers.\nnum_keys::Int64: Number of keys to be generated.\n\nReturns\n\nkeys::Array{Int64, 1}: Generated pseudo-random keys.\n\nExample\n\njulia> logistic_key(0.01, 3.97, 20)\n20-element Array{Int64,1}:\n   0\n  44\n   7\n  26\n  14\n 224\n  16\n 250\n 162\n 211\n 200\n 217\n  97\n 132\n 134\n 100\n 135\n 232\n 122\n\n\n\n\n\n","category":"method"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"lorenz_key(\n    x_init::Float64,\n    y_init::Float64,\n    z_init::Float64,\n    num_keys::Int64,\n    α::Float64=10.0,\n    ρ::Float64=28.0,\n    β::Float64=2.667,\n    dt::Float64=0.01\n)","category":"page"},{"location":"#ChaoticEncryption.lorenz_key","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.lorenz_key","text":"lorenz_key(x_init, y_init, z_init, num_keys, α=10.0, ρ=28.0, β=2.667, dt=0.01)\n\nGenerates 3 lists of pseudo-random numbers using Lorenz system of differential equations.\n\nThe equations -\n\nfracdxdt = α * (y - x)\n\nfracdydt = x * (ρ - z) - y\n\nfracdzdt = x * y - β * z\n\nArguments\n\nx_init::Float64: Initial value of x.\ny_init::Float64: Initial value of y.\nz_init::Float64: Initial value of z.\nnum_keys::Int64: Number of keys (in a single list) to be generated.\nα::Float64: Constant associated with Lorenz system of differential equations.\nρ::Float64: Constant associated with Lorenz system of differential equations.\nβ::Float64: Constant associated with Lorenz system of differential equations.\n\nReturns\n\nx::Array{Int64, 1}: Generated pseudo-random keys corresponding to x values.\ny::Array{Int64, 1}: Generated pseudo-random keys corresponding to y values.\nz::Array{Int64, 1}: Generated pseudo-random keys corresponding to z values.\n\nExample\n\njulia> lorenz_key(0.01, 0.02, 0.03, 20)\n([0, 0, 256, 24, 129, 42, 54, 134, 43, 179, 85, 19, 24, 44, 71, 210, 238, 152, 22, 27],\n[0, 0, 240, 55, 25, 163, 89, 243, 123, 5, 197, 64, 227, 54, 188, 226, 154, 134, 64, 69],\n[0, 0, 80, 227, 178, 204, 89, 33, 144, 139, 105, 208, 108, 155, 61, 254, 57, 102, 149, 47])\n\n\n\n\n\n","category":"function"},{"location":"#Encryption-methods","page":"ChaoticEncryption.jl","title":"Encryption methods","text":"","category":"section"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"substitution_encryption(\n    path_to_image::String,\n    keys::Array{Int64, 1},\n    path_for_result::String=\"./encrypted.png\",\n)","category":"page"},{"location":"#ChaoticEncryption.substitution_encryption","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.substitution_encryption","text":"substitution_encryption(path_to_image, keys, path_for_result=\"./encrypted.png\")\n\nPerforms substitution encryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the order of the keys matter.\n\nArguments\n\npath_to_image::String: The path to the image to be encrypted.\nkeys::Array{Int64, 1}: Keys for encryption.\npath_for_result::String: The path for storing the encrypted image.\n\nExample\n\njulia> keys = logistic_key(0.01, 3.97, 719 * 718)\n516242-element Array{Any,1}:\n   0\n  44\n   7\n  26\n  14\n 224\n   ⋮\n 115\n  65\n 126\n 152\n  74\n 198\njulia> substitution_encryption(\"D:\\Saransh\\Docs\\PyCon_Squared.jpg\", keys)\nENCRYPTING\nENCRYPTED\n\n\n\n\n\n","category":"function"},{"location":"","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.jl","text":"substitution_decryption(\n    path_to_image::String,\n    keys::Array{Int64, 1},\n    path_for_result::String=\"./decrypted.png\",\n)","category":"page"},{"location":"#ChaoticEncryption.substitution_decryption","page":"ChaoticEncryption.jl","title":"ChaoticEncryption.substitution_decryption","text":"substitution_decryption(path_to_image, keys, path_for_result=\"./decrypted.png\")\n\nPerforms substitution decryption on a given image with the given keys.\n\nAlgorithm\n\nIterates simulataneously over each pixel and key, and XORs the pixel value (all R, G, and B) with the given key. Hence, the keys provided must be the same as the ones provided during encryption.\n\nArguments\n\npath_to_image::String: The path to the image to be decrypted.\nkeys::Array{Int64, 1}: Keys for decryption.\npath_for_result::String: The path for storing the decrypted image.\n\nExample\n\njulia> substitution_decryption(\"./encrypted.png\", keys)\nDECRYPTING\nDECRYPTED\n\n\n\n\n\n","category":"function"}]
}
